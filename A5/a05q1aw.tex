\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{ifthen,enumerate}
\usepackage{listings}
\usepackage{courier}
\usepackage{pdfpages}
\usepackage{qtree}
%\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{../thm}
\usepackage[left=3.8cm,top=3.8cm,right=3.8cm]{geometry}
\title{Responses for CS240 Assignment 5 Question 1a}
\author{Alfred Chan -- 20392255}

\begin{document}
\lstset{
	language=c,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{red}\bfseries,
  stringstyle=\ttfamily\color{red!50!brown},
	numbers=left,
	showspaces=false,
	showstringspaces=false,
	stepnumber=1,
	basicstyle=\ttfamily,
	morekeywords={or ,and, then},
	frame=single,
	breaklines=true,
	tabsize=2
}
\maketitle

Suppose $A$ is an array of int, $l$ and $r$ are indices of the beginning and the end of the search range, respectively, and $k$ is the target value. Consider 3 functions:
\begin{enumerate}
\item
$interpolate(A, l, r, k)$, which is the given formula. Notice that I purposedly separate it from the base function because I wrote the codes in c++, and this kind of separation of codes allows me to adapt the algorithm to a basic binary search, which serves as a source of verification.
\item
$isearch(interpolate, A, l, r, k)$, which is a higher order function that serves as the base of the interpolation search.
Notice that $interpolate$ is a function.
\item
$delta(numFailures)$, which returns the balance adjustment for the search index.
\end{enumerate}

Pseudocode:
\begin{align}
interpolate(A, l, r, k) &= \ell+\left\lfloor\frac{k-A[\ell]}{A[r]-A[\ell]}(r-\ell)\right\rfloor\\
delta(numFailures) &= numFailures
\end{align}

\begin{lstlisting}
interpolate(A, l, r, k)
\end{lstlisting}

\hfill $\blacksquare$
\end{document}
